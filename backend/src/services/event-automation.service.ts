/**
 * @fileoverview Event Automation Service
 * Core engine for event lifecycle: creation ‚Üí reminders ‚Üí completion ‚Üí follow-ups ‚Üí analytics
 * 
 * Flow:
 * 1. Agent creates event (via API or template)
 * 2. System auto-creates reminders based on template presets
 * 3. Reminder processor sends notifications at scheduled times
 * 4. On event completion, system auto-creates follow-up events
 * 5. Analytics are tracked throughout the lifecycle
 * 6. Next steps are suggested to the agent
 */

import { container } from '../lib/container'
import { logger } from '../lib/logger'
import type {
  ReminderPreset,
  FollowUpRules,
} from '../database/schema/events'

// =============================================================================
// Types
// =============================================================================

export interface CreateEventInput {
  title: string;
  eventType: string;
  templateId?: number;
  startTime: string;
  endTime: string;
  allDay?: boolean;
  timezone?: string;
  location?: string;
  locationLat?: number;
  locationLng?: number;
  virtualMeetingUrl?: string;
  description?: string;
  internalNotes?: string;
  propertyId?: number;
  clientId?: number;
  agentId: number;
  metadata?: Record<string, unknown>;
  attendees?: Array<{
    clientId?: number;
    userId?: number;
    name?: string;
    email?: string;
    phone?: string;
    notifyEmail?: boolean;
    notifySms?: boolean;
  }>;
  // Override default reminders
  customReminders?: Array<{ channel: string; minutesBefore: number }>;
  // Skip automation (for manual events)
  skipAutomation?: boolean;
}

export interface CompleteEventInput {
  outcomeNotes?: string;
  metadata?: Record<string, unknown>;
  clientSatisfaction?: number;
  clientFeedback?: string;
  ledToOffer?: boolean;
  ledToContract?: boolean;
  conversionValue?: number;
  skipFollowUp?: boolean;
}

export interface EventWithRelations {
  id: number;
  title: string;
  eventType: string;
  status: string;
  startTime: string;
  endTime: string;
  location: string | null;
  description: string | null;
  propertyId: number | null;
  clientId: number | null;
  agentId: number;
  metadata: Record<string, unknown>;
  template: { name: string; color: string; icon: string; suggestedNextSteps: string[] } | null;
  attendees: Array<{ id: number; name: string | null; email: string | null; rsvpStatus: string }>;
  reminders: Array<{ id: number; channel: string; minutesBefore: number; status: string; remindAt: string }>;
  analytics: { clientSatisfaction: number | null; ledToOffer: boolean; followUpCreated: boolean } | null;
  parentEventId: number | null;
  autoGenerated: boolean;
  createdAt: string;
}

export interface EventAnalyticsSummary {
  totalEvents: number;
  completedEvents: number;
  cancelledEvents: number;
  noShowEvents: number;
  completionRate: number;
  avgTimeToComplete: number | null;
  conversionToOffer: number;
  conversionToContract: number;
  avgClientSatisfaction: number | null;
  avgDaysToFollowUp: number | null;
  eventsByType: Record<string, number>;
  eventsByStatus: Record<string, number>;
  topAgents: Array<{ agentId: number; completedCount: number }>;
  monthlyTrend: Array<{ month: string; count: number; completionRate: number }>;
}

// =============================================================================
// Event CRUD with Automation
// =============================================================================

/**
 * Create event with full automation pipeline:
 * - Auto-apply template defaults
 * - Create attendees
 * - Schedule reminders from template presets
 * - Log activity
 */
export async function createEvent(input: CreateEventInput, createdBy: number): Promise<EventWithRelations> {
  const db = container.getDatabase()

  // 1. Load template if specified
  let template: Record<string, unknown> | null = null
  if (input.templateId) {
    const rows = await db`SELECT * FROM event_templates WHERE id = ${input.templateId} AND is_active = true`
    if (rows.length > 0) template = rows[0] as Record<string, unknown>
  } else {
    // Auto-find template by event type
    const rows = await db`SELECT * FROM event_templates WHERE event_type = ${input.eventType} AND is_active = true AND is_system = true LIMIT 1`
    if (rows.length > 0) template = rows[0] as Record<string, unknown>
  }

  // 2. Apply template defaults
  const endTime = input.endTime || (template
    ? new Date(new Date(input.startTime).getTime() + (template.default_duration_minutes as number) * 60000).toISOString()
    : new Date(new Date(input.startTime).getTime() + 60 * 60000).toISOString())

  // 3. Render description template
  let description = input.description
  if (!description && template?.default_description_template) {
    description = await renderTemplate(
      template.default_description_template as string,
      input.propertyId,
      input.clientId
    )
  }

  // 4. Insert event
  const [event] = await db`
    INSERT INTO events (
      title, event_type, status, template_id,
      start_time, end_time, all_day, timezone,
      location, location_lat, location_lng, virtual_meeting_url,
      description, internal_notes,
      property_id, client_id, agent_id,
      metadata, created_by
    ) VALUES (
      ${input.title}, ${input.eventType}, 'scheduled', ${template ? (template.id as number) : null},
      ${input.startTime}, ${endTime}, ${input.allDay || false}, ${input.timezone || 'Europe/Madrid'},
      ${input.location || (template?.default_location as string | null) || null},
      ${input.locationLat || null}, ${input.locationLng || null}, ${input.virtualMeetingUrl || null},
      ${description || null}, ${input.internalNotes || null},
      ${input.propertyId || null}, ${input.clientId || null}, ${input.agentId},
      ${JSON.stringify(input.metadata || {})}, ${createdBy}
    ) RETURNING *
  `

  const eventId = event.id as number

  // 5. Create attendees
  if (input.attendees?.length) {
    for (const att of input.attendees) {
      await db`
        INSERT INTO event_attendees (event_id, client_id, user_id, name, email, phone, notify_email, notify_sms)
        VALUES (${eventId}, ${att.clientId || null}, ${att.userId || null}, 
                ${att.name || null}, ${att.email || null}, ${att.phone || null},
                ${att.notifyEmail ?? true}, ${att.notifySms ?? false})
      `
    }
  }

  // Auto-add client as attendee if not already
  if (input.clientId) {
    const existingAttendee = input.attendees?.find(a => a.clientId === input.clientId)
    if (!existingAttendee) {
      const clientRows = await db`SELECT full_name, email, phone FROM clients WHERE id = ${input.clientId}`
      if (clientRows.length > 0) {
        const client = clientRows[0]
        await db`
          INSERT INTO event_attendees (event_id, client_id, name, email, phone, notify_email, notify_sms)
          VALUES (${eventId}, ${input.clientId}, ${client.full_name}, ${client.email || null}, ${client.phone || null}, true, ${!!client.phone})
        `
      }
    }
  }

  // Auto-add agent as attendee
  await db`
    INSERT INTO event_attendees (event_id, user_id, notify_email, notify_sms)
    VALUES (${eventId}, ${input.agentId}, true, false)
    ON CONFLICT DO NOTHING
  `

  // 6. Schedule reminders (from template or custom)
  if (!input.skipAutomation) {
    const reminderPresets: ReminderPreset[] = input.customReminders?.map(r => ({
      channel: r.channel as ReminderPreset['channel'],
      minutes_before: r.minutesBefore,
    })) || (template?.reminder_presets as ReminderPreset[] || [])

    await scheduleReminders(eventId, new Date(input.startTime), reminderPresets, input.agentId)
  }

  // 7. Create analytics row
  await db`INSERT INTO event_analytics (event_id) VALUES (${eventId})`

  // 8. Log activity
  await logActivity(eventId, 'created', null, { eventType: input.eventType, title: input.title }, createdBy)

  // 9. Return full event
  return getEventById(eventId)
}

/**
 * Complete an event - triggers follow-up automation
 */
export async function completeEvent(
  eventId: number,
  input: CompleteEventInput,
  completedBy: number
): Promise<{ event: EventWithRelations; followUpEvent?: EventWithRelations; suggestedNextSteps: string[] }> {
  const db = container.getDatabase()

  // 1. Update event status
  const now = new Date().toISOString()
  await db`
    UPDATE events SET 
      status = 'completed', 
      completed_at = ${now},
      outcome_notes = COALESCE(${input.outcomeNotes || null}, outcome_notes),
      metadata = metadata || ${JSON.stringify(input.metadata || {})}::jsonb,
      updated_at = NOW()
    WHERE id = ${eventId}
  `

  // 2. Update analytics
  const [eventRow] = await db`SELECT start_time, event_type, template_id, property_id, client_id, agent_id FROM events WHERE id = ${eventId}`
  const timeToComplete = Math.round((Date.now() - new Date(eventRow.start_time as string).getTime()) / 60000)

  await db`
    UPDATE event_analytics SET
      time_to_complete_minutes = ${timeToComplete},
      client_satisfaction = ${input.clientSatisfaction || null},
      client_feedback = ${input.clientFeedback || null},
      led_to_offer = ${input.ledToOffer || false},
      led_to_contract = ${input.ledToContract || false},
      conversion_value = ${input.conversionValue || null},
      updated_at = NOW()
    WHERE event_id = ${eventId}
  `

  // 3. Cancel pending reminders
  await db`UPDATE event_reminders SET status = 'cancelled' WHERE event_id = ${eventId} AND status = 'pending'`

  // 4. Log activity
  await logActivity(eventId, 'completed', { status: 'scheduled' }, { status: 'completed', outcomeNotes: input.outcomeNotes }, completedBy)

  // 5. Auto-create follow-up if template has rules
  let followUpEvent: EventWithRelations | undefined
  const suggestedNextSteps: string[] = []

  if (!input.skipFollowUp && eventRow.template_id) {
    const [tmpl] = await db`SELECT follow_up_rules, suggested_next_steps FROM event_templates WHERE id = ${eventRow.template_id}`
    
    if (tmpl) {
      const rules = tmpl.follow_up_rules as FollowUpRules
      const steps = tmpl.suggested_next_steps as string[]
      
      if (steps?.length) suggestedNextSteps.push(...steps)

      if (rules?.auto_create && rules.delay_hours && rules.follow_up_type) {
        const followUpStart = new Date(Date.now() + rules.delay_hours * 3600000)
        
        // Find follow-up template
        let followUpTemplateId: number | undefined
        if (rules.template_name) {
          const [ft] = await db`SELECT id FROM event_templates WHERE name = ${rules.template_name} AND is_active = true`
          if (ft) followUpTemplateId = ft.id as number
        }

        followUpEvent = await createEvent({
          title: `Follow-up: ${eventRow.event_type} #${eventId}`,
          eventType: rules.follow_up_type,
          templateId: followUpTemplateId,
          startTime: followUpStart.toISOString(),
          endTime: new Date(followUpStart.getTime() + 30 * 60000).toISOString(),
          propertyId: eventRow.property_id as number | undefined,
          clientId: eventRow.client_id as number | undefined,
          agentId: eventRow.agent_id as number,
          metadata: { parentEventId: eventId, autoGenerated: true },
        }, completedBy)

        // Update parent event to link follow-up
        await db`UPDATE events SET parent_event_id = ${eventId} WHERE id = ${followUpEvent.id}`

        // Update analytics
        await db`
          UPDATE event_analytics SET 
            follow_up_created = true,
            follow_up_event_id = ${followUpEvent.id},
            days_to_follow_up = ${Math.round(rules.delay_hours / 24)}
          WHERE event_id = ${eventId}
        `

        await logActivity(eventId, 'follow_up_created', null, { followUpEventId: followUpEvent.id }, completedBy)
      }
    }
  }

  const event = await getEventById(eventId)
  return { event, followUpEvent, suggestedNextSteps }
}

/**
 * Cancel an event
 */
export async function cancelEvent(eventId: number, reason: string, cancelledBy: number): Promise<EventWithRelations> {
  const db = container.getDatabase()
  
  await db`
    UPDATE events SET status = 'cancelled', cancelled_at = NOW(), cancellation_reason = ${reason}, updated_at = NOW()
    WHERE id = ${eventId}
  `
  await db`UPDATE event_reminders SET status = 'cancelled' WHERE event_id = ${eventId} AND status = 'pending'`
  await logActivity(eventId, 'cancelled', null, { reason }, cancelledBy)

  return getEventById(eventId)
}

/**
 * Mark event as no-show
 */
export async function markNoShow(eventId: number, notes: string | undefined, markedBy: number): Promise<EventWithRelations> {
  const db = container.getDatabase()
  
  await db`
    UPDATE events SET status = 'no_show', outcome_notes = ${notes || 'No show'}, updated_at = NOW()
    WHERE id = ${eventId}
  `
  await db`UPDATE event_reminders SET status = 'cancelled' WHERE event_id = ${eventId} AND status = 'pending'`
  await logActivity(eventId, 'no_show', null, { notes }, markedBy)

  return getEventById(eventId)
}

// =============================================================================
// Query Functions
// =============================================================================

export async function getEventById(eventId: number): Promise<EventWithRelations> {
  const db = container.getDatabase()
  
  const [event] = await db`SELECT * FROM events WHERE id = ${eventId} AND deleted_at IS NULL`
  if (!event) throw new Error(`Event not found: ${eventId}`)

  const attendees = await db`SELECT * FROM event_attendees WHERE event_id = ${eventId}`
  const reminders = await db`SELECT * FROM event_reminders WHERE event_id = ${eventId} ORDER BY remind_at`
  const [analytics] = await db`SELECT * FROM event_analytics WHERE event_id = ${eventId}`
  
  let template = null
  if (event.template_id) {
    const [t] = await db`SELECT name, color, icon, suggested_next_steps FROM event_templates WHERE id = ${event.template_id}`
    if (t) template = { 
      name: t.name as string, 
      color: t.color as string, 
      icon: t.icon as string, 
      suggestedNextSteps: (t.suggested_next_steps || []) as string[] 
    }
  }

  return {
    id: event.id as number,
    title: event.title as string,
    eventType: event.event_type as string,
    status: event.status as string,
    startTime: (event.start_time as Date).toISOString(),
    endTime: (event.end_time as Date).toISOString(),
    location: event.location as string | null,
    description: event.description as string | null,
    propertyId: event.property_id as number | null,
    clientId: event.client_id as number | null,
    agentId: event.agent_id as number,
    metadata: (event.metadata || {}) as Record<string, unknown>,
    template,
    attendees: attendees.map(a => ({
      id: a.id as number,
      name: a.name as string | null,
      email: a.email as string | null,
      rsvpStatus: a.rsvp_status as string,
    })),
    reminders: reminders.map(r => ({
      id: r.id as number,
      channel: r.channel as string,
      minutesBefore: r.minutes_before as number,
      status: r.status as string,
      remindAt: (r.remind_at as Date).toISOString(),
    })),
    analytics: analytics ? {
      clientSatisfaction: analytics.client_satisfaction as number | null,
      ledToOffer: analytics.led_to_offer as boolean,
      followUpCreated: analytics.follow_up_created as boolean,
    } : null,
    parentEventId: event.parent_event_id as number | null,
    autoGenerated: event.auto_generated as boolean,
    createdAt: (event.created_at as Date).toISOString(),
  }
}

export async function listEvents(filters: {
  agentId?: number;
  clientId?: number;
  propertyId?: number;
  eventType?: string;
  status?: string;
  startFrom?: string;
  startTo?: string;
  limit?: number;
  offset?: number;
}): Promise<{ events: EventWithRelations[]; total: number }> {
  const db = container.getDatabase()

  // Build WHERE conditions dynamically
  const conditions: string[] = ['e.deleted_at IS NULL']
  const params: unknown[] = []
  let paramIdx = 1

  if (filters.agentId) { conditions.push(`e.agent_id = $${paramIdx++}`); params.push(filters.agentId) }
  if (filters.clientId) { conditions.push(`e.client_id = $${paramIdx++}`); params.push(filters.clientId) }
  if (filters.propertyId) { conditions.push(`e.property_id = $${paramIdx++}`); params.push(filters.propertyId) }
  if (filters.eventType) { conditions.push(`e.event_type = $${paramIdx++}`); params.push(filters.eventType) }
  if (filters.status) { conditions.push(`e.status = $${paramIdx++}`); params.push(filters.status) }
  if (filters.startFrom) { conditions.push(`e.start_time >= $${paramIdx++}`); params.push(filters.startFrom) }
  if (filters.startTo) { conditions.push(`e.start_time <= $${paramIdx++}`); params.push(filters.startTo) }

  // Use simpler approach with tagged templates for safety
  const whereClause = conditions.join(' AND ')
  const limit = filters.limit || 50
  const offset = filters.offset || 0

  // Get IDs with filters
  const rows = await db.unsafe(
    `SELECT e.id FROM events e WHERE ${whereClause} ORDER BY e.start_time DESC LIMIT ${limit} OFFSET ${offset}`,
    params
  )
  
  const countRows = await db.unsafe(
    `SELECT COUNT(*) as total FROM events e WHERE ${whereClause}`,
    params
  )

  const eventIds = rows.map(r => r.id as number)
  const eventsList = await Promise.all(eventIds.map(id => getEventById(id)))

  return {
    events: eventsList,
    total: Number(countRows[0]?.total || 0),
  }
}

// =============================================================================
// Templates
// =============================================================================

export async function listTemplates(activeOnly = true) {
  const db = container.getDatabase()
  if (activeOnly) {
    return db`SELECT * FROM event_templates WHERE is_active = true ORDER BY event_type, name`
  }
  return db`SELECT * FROM event_templates ORDER BY event_type, name`
}

export async function getTemplateByName(name: string) {
  const db = container.getDatabase()
  const [row] = await db`SELECT * FROM event_templates WHERE name = ${name}`
  return row || null
}

// =============================================================================
// Reminder Processing
// =============================================================================

/**
 * Schedule reminders for an event based on presets
 */
async function scheduleReminders(
  eventId: number,
  startTime: Date,
  presets: ReminderPreset[],
  agentUserId: number
): Promise<void> {
  const db = container.getDatabase()

  for (const preset of presets) {
    const remindAt = new Date(startTime.getTime() - preset.minutes_before * 60000)
    
    // Don't schedule reminders in the past
    if (remindAt <= new Date()) continue

    // Determine target based on channel
    if (preset.channel === 'in_app' || preset.channel === 'push') {
      // Notify the agent
      await db`
        INSERT INTO event_reminders (event_id, remind_at, minutes_before, channel, target_user_id, status)
        VALUES (${eventId}, ${remindAt.toISOString()}, ${preset.minutes_before}, ${preset.channel}, ${agentUserId}, 'pending')
      `
    } else {
      // For email/SMS, create reminders for all attendees with matching notification preference
      const attendees = await db`
        SELECT * FROM event_attendees WHERE event_id = ${eventId}
        AND (
          (${preset.channel} = 'email' AND notify_email = true AND email IS NOT NULL)
          OR (${preset.channel} = 'sms' AND notify_sms = true AND phone IS NOT NULL)
        )
      `

      for (const att of attendees) {
        await db`
          INSERT INTO event_reminders (event_id, remind_at, minutes_before, channel, attendee_id, target_email, target_phone, status)
          VALUES (${eventId}, ${remindAt.toISOString()}, ${preset.minutes_before}, ${preset.channel},
                  ${att.id}, ${att.email || null}, ${att.phone || null}, 'pending')
        `
      }

      // Also notify agent
      await db`
        INSERT INTO event_reminders (event_id, remind_at, minutes_before, channel, target_user_id, status)
        VALUES (${eventId}, ${remindAt.toISOString()}, ${preset.minutes_before}, ${preset.channel}, ${agentUserId}, 'pending')
      `
    }
  }
}

/**
 * Process due reminders - call this periodically (e.g., every minute via cron)
 * Returns count of processed reminders
 */
export async function processPendingReminders(): Promise<number> {
  const db = container.getDatabase()
  
  // Get all due reminders
  const dueReminders = await db`
    SELECT r.*, e.title as event_title, e.start_time as event_start, e.location as event_location,
           e.event_type, e.property_id, e.client_id
    FROM event_reminders r
    JOIN events e ON r.event_id = e.id
    WHERE r.status = 'pending' AND r.remind_at <= NOW()
    AND e.status IN ('scheduled', 'confirmed')
    ORDER BY r.remind_at
    LIMIT 100
  `

  let processed = 0

  for (const reminder of dueReminders) {
    try {
      // Render reminder content
      const { subject, body } = renderReminderContent(reminder)

      // Send based on channel
      switch (reminder.channel) {
        case 'email':
          await sendEmailReminder(reminder.target_email as string, subject, body)
          break
        case 'sms':
          await sendSmsReminder(reminder.target_phone as string, body)
          break
        case 'in_app':
          await sendInAppReminder(reminder.target_user_id as number, subject, body, reminder.event_id as number)
          break
        case 'push':
          await sendPushReminder(reminder.target_user_id as number, subject, body)
          break
      }

      // Mark as sent
      await db`
        UPDATE event_reminders SET status = 'sent', sent_at = NOW(), subject = ${subject}, body = ${body}
        WHERE id = ${reminder.id}
      `

      await logActivity(
        reminder.event_id as number, 
        'reminder_sent', 
        null, 
        { channel: reminder.channel, minutesBefore: reminder.minutes_before },
        null
      )

      processed++
    } catch (error) {
      const retryCount = (reminder.retry_count as number) + 1
      const errorMsg = error instanceof Error ? error.message : String(error)
      
      if (retryCount >= 3) {
        await db`UPDATE event_reminders SET status = 'failed', error_message = ${errorMsg}, retry_count = ${retryCount} WHERE id = ${reminder.id}`
      } else {
        // Retry in 5 minutes
        const nextRetry = new Date(Date.now() + 5 * 60000).toISOString()
        await db`UPDATE event_reminders SET remind_at = ${nextRetry}, retry_count = ${retryCount}, error_message = ${errorMsg} WHERE id = ${reminder.id}`
      }
      
      logger.warn('Failed to send reminder', { reminderId: reminder.id, error: errorMsg })
    }
  }

  if (processed > 0) {
    logger.info('Processed reminders', { processed, total: dueReminders.length })
  }

  return processed
}

// =============================================================================
// Notification Senders
// =============================================================================

async function sendEmailReminder(email: string, subject: string, body: string): Promise<void> {
  // Queue email via the existing email_queue system
  const db = container.getDatabase()
  await db`
    INSERT INTO email_queue (to_email, subject, template_name, html_content, text_content, status, priority)
    VALUES (${email}, ${subject}, 'custom', ${wrapHtmlEmail(subject, body)}, ${body}, 'pending', 2)
  `
  logger.debug('Email reminder queued', { email, subject })
}

async function sendSmsReminder(phone: string, body: string): Promise<void> {
  // SMS integration placeholder - would connect to Twilio, Vonage, etc.
  logger.info('SMS reminder would be sent', { phone, bodyLength: body.length })
  // TODO: Integrate with SMS provider
  // For now, also create an in-app notification as fallback
}

async function sendInAppReminder(userId: number, title: string, body: string, eventId: number): Promise<void> {
  const db = container.getDatabase()
  await db`
    INSERT INTO notifications (user_id, type, title, message, entity_type, entity_id, action_url, metadata)
    VALUES (${userId}, 'info', ${title}, ${body}, 'event', ${eventId}, ${`/dashboard/events/${eventId}`}, 
            ${JSON.stringify({ source: 'event_reminder' })})
  `
}

async function sendPushReminder(userId: number, title: string, body: string): Promise<void> {
  // Push notification placeholder - would connect to FCM, APNs, web push
  logger.info('Push reminder would be sent', { userId, title })
  // Fallback to in-app
  // For now we always create in-app notification as well
}

// =============================================================================
// Analytics
// =============================================================================

export async function getEventAnalytics(filters: {
  agentId?: number;
  dateFrom?: string;
  dateTo?: string;
  eventType?: string;
}): Promise<EventAnalyticsSummary> {
  const db = container.getDatabase()

  const conditions: string[] = ['e.deleted_at IS NULL']
  const params: unknown[] = []
  let idx = 1

  if (filters.agentId) { conditions.push(`e.agent_id = $${idx++}`); params.push(filters.agentId) }
  if (filters.dateFrom) { conditions.push(`e.start_time >= $${idx++}`); params.push(filters.dateFrom) }
  if (filters.dateTo) { conditions.push(`e.start_time <= $${idx++}`); params.push(filters.dateTo) }
  if (filters.eventType) { conditions.push(`e.event_type = $${idx++}`); params.push(filters.eventType) }

  const where = conditions.join(' AND ')

  // Main metrics
  const [metrics] = await db.unsafe(`
    SELECT 
      COUNT(*) as total,
      COUNT(*) FILTER (WHERE e.status = 'completed') as completed,
      COUNT(*) FILTER (WHERE e.status = 'cancelled') as cancelled,
      COUNT(*) FILTER (WHERE e.status = 'no_show') as no_show,
      ROUND(AVG(a.time_to_complete_minutes) FILTER (WHERE a.time_to_complete_minutes IS NOT NULL)) as avg_completion,
      COUNT(*) FILTER (WHERE a.led_to_offer = true) as offers,
      COUNT(*) FILTER (WHERE a.led_to_contract = true) as contracts,
      ROUND(AVG(a.client_satisfaction) FILTER (WHERE a.client_satisfaction IS NOT NULL), 1) as avg_satisfaction,
      ROUND(AVG(a.days_to_follow_up) FILTER (WHERE a.days_to_follow_up IS NOT NULL), 1) as avg_follow_up_days
    FROM events e
    LEFT JOIN event_analytics a ON e.id = a.event_id
    WHERE ${where}
  `, params)

  // Events by type
  const typeRows = await db.unsafe(`
    SELECT e.event_type, COUNT(*) as count FROM events e WHERE ${where} GROUP BY e.event_type
  `, params)

  // Events by status
  const statusRows = await db.unsafe(`
    SELECT e.status, COUNT(*) as count FROM events e WHERE ${where} GROUP BY e.status
  `, params)

  // Top agents
  const agentRows = await db.unsafe(`
    SELECT e.agent_id, COUNT(*) as count 
    FROM events e WHERE ${where} AND e.status = 'completed'
    GROUP BY e.agent_id ORDER BY count DESC LIMIT 10
  `, params)

  // Monthly trend (last 12 months)
  const trendRows = await db.unsafe(`
    SELECT 
      TO_CHAR(e.start_time, 'YYYY-MM') as month,
      COUNT(*) as total,
      COUNT(*) FILTER (WHERE e.status = 'completed') as completed
    FROM events e WHERE ${where}
    GROUP BY month ORDER BY month DESC LIMIT 12
  `, params)

  const total = Number(metrics.total)

  return {
    totalEvents: total,
    completedEvents: Number(metrics.completed),
    cancelledEvents: Number(metrics.cancelled),
    noShowEvents: Number(metrics.no_show),
    completionRate: total > 0 ? Number(metrics.completed) / total : 0,
    avgTimeToComplete: metrics.avg_completion ? Number(metrics.avg_completion) : null,
    conversionToOffer: total > 0 ? Number(metrics.offers) / total : 0,
    conversionToContract: total > 0 ? Number(metrics.contracts) / total : 0,
    avgClientSatisfaction: metrics.avg_satisfaction ? Number(metrics.avg_satisfaction) : null,
    avgDaysToFollowUp: metrics.avg_follow_up_days ? Number(metrics.avg_follow_up_days) : null,
    eventsByType: Object.fromEntries(typeRows.map(r => [r.event_type, Number(r.count)])),
    eventsByStatus: Object.fromEntries(statusRows.map(r => [r.status, Number(r.count)])),
    topAgents: agentRows.map(r => ({ agentId: Number(r.agent_id), completedCount: Number(r.count) })),
    monthlyTrend: trendRows.map(r => ({
      month: r.month as string,
      count: Number(r.total),
      completionRate: Number(r.total) > 0 ? Number(r.completed) / Number(r.total) : 0,
    })),
  }
}

// =============================================================================
// Helpers
// =============================================================================

async function renderTemplate(template: string, propertyId?: number, clientId?: number): Promise<string> {
  const db = container.getDatabase()
  let result = template

  if (propertyId) {
    const [prop] = await db`SELECT title, address FROM properties WHERE id = ${propertyId}`
    if (prop) {
      result = result.replace(/\{\{property_address\}\}/g, (prop.address || prop.title || '') as string)
      result = result.replace(/\{\{property_title\}\}/g, (prop.title || '') as string)
    }
  }

  if (clientId) {
    const [client] = await db`SELECT full_name FROM clients WHERE id = ${clientId}`
    if (client) {
      result = result.replace(/\{\{client_name\}\}/g, client.full_name as string)
    }
  }

  return result
}

function renderReminderContent(reminder: Record<string, unknown>): { subject: string; body: string } {
  const minutesBefore = reminder.minutes_before as number
  const eventTitle = reminder.event_title as string
  const eventStart = new Date(reminder.event_start as string)
  const location = reminder.event_location as string | null

  let timeLabel: string
  if (minutesBefore >= 1440) {
    timeLabel = `${Math.round(minutesBefore / 1440)} day(s)`
  } else if (minutesBefore >= 60) {
    timeLabel = `${Math.round(minutesBefore / 60)} hour(s)`
  } else {
    timeLabel = `${minutesBefore} minutes`
  }

  const subject = `‚è∞ Reminder: ${eventTitle} in ${timeLabel}`
  const body = [
    `Your event "${eventTitle}" is starting in ${timeLabel}.`,
    `üìÖ ${eventStart.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`,
    `üïê ${eventStart.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}`,
    location ? `üìç ${location}` : null,
    '',
    'Don\'t forget to prepare!',
  ].filter(Boolean).join('\n')

  return { subject, body }
}

function wrapHtmlEmail(title: string, body: string): string {
  return `<!DOCTYPE html>
<html><head><meta charset="utf-8"></head>
<body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2 style="color: #1a1a1a;">${title}</h2>
  <div style="white-space: pre-line; color: #333; line-height: 1.6;">${body}</div>
  <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
  <p style="color: #999; font-size: 12px;">Inmobiliaria System - Automated Reminder</p>
</body></html>`
}

async function logActivity(
  eventId: number,
  action: string,
  oldValue: unknown,
  newValue: unknown,
  performedBy: number | null
): Promise<void> {
  const db = container.getDatabase()
  try {
    await db`
      INSERT INTO event_activity_log (event_id, action, old_value, new_value, performed_by)
      VALUES (${eventId}, ${action}, ${oldValue ? JSON.stringify(oldValue) : null}, ${newValue ? JSON.stringify(newValue) : null}, ${performedBy})
    `
  } catch (error) {
    logger.warn('Failed to log event activity', { eventId, action, error })
  }
}
